{"ast":null,"code":"var TRAILING_WHITESPACE = /[ \\u0020\\t\\n]*$/; // This escapes some markdown but there's a few cases that are TODO -\n// - List items\n// - Back tics  (see https://github.com/Rosey/markdown-draft-js/issues/52#issuecomment-388458017)\n// - Complex markdown, like links or images. Not sure it's even worth it, because if you're typing\n// that into draft chances are you know its markdown and maybe expect it convert? :/\n\nvar MARKDOWN_STYLE_CHARACTERS = ['*', '_', '~', '`'];\nvar MARKDOWN_STYLE_CHARACTER_REGXP = /(\\*|_|~|\\\\|`)/g; // I hate this a bit, being outside of the function’s scope\n// but can’t think of a better way to keep track of how many ordered list\n// items were are on, as draft doesn’t explicitly tell us in the raw object 😢.\n// This is a hash that will be assigned values based on depth, so like\n// orderedListNumber[0] = 1 would mean that ordered list at depth 0 is on number 1.\n// orderedListNumber[0] = 2 would mean that ordered list at depth 0 is on number 2.\n// This is so we have the right number of numbers when doing a list, eg\n// 1. Item One\n// 2. Item two\n// 3. Item three\n// And so on.\n\nvar orderedListNumber = {},\n    previousOrderedListDepth = 0; // A map of draftjs block types -> markdown open and close characters\n// Both the open and close methods must exist, even if they simply return an empty string.\n// They should always return a string.\n\nvar StyleItems = {\n  // BLOCK LEVEL\n  'unordered-list-item': {\n    open: function open() {\n      return '- ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'ordered-list-item': {\n    open: function open(block) {\n      var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return \"\".concat(number, \". \");\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'blockquote': {\n    open: function open() {\n      return '> ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'header-one': {\n    open: function open() {\n      return '# ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'header-two': {\n    open: function open() {\n      return '## ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'header-three': {\n    open: function open() {\n      return '### ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'header-four': {\n    open: function open() {\n      return '#### ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'header-five': {\n    open: function open() {\n      return '##### ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'header-six': {\n    open: function open() {\n      return '###### ';\n    },\n    close: function close() {\n      return '';\n    }\n  },\n  'code-block': {\n    open: function open(block) {\n      return '```' + (block.data.language || '') + '\\n';\n    },\n    close: function close() {\n      return '\\n```';\n    }\n  },\n  // INLINE LEVEL\n  'BOLD': {\n    open: function open() {\n      return '**';\n    },\n    close: function close() {\n      return '**';\n    }\n  },\n  'ITALIC': {\n    open: function open() {\n      return '_';\n    },\n    close: function close() {\n      return '_';\n    }\n  },\n  'STRIKETHROUGH': {\n    open: function open() {\n      return '~~';\n    },\n    close: function close() {\n      return '~~';\n    }\n  },\n  'CODE': {\n    open: function open() {\n      return '`';\n    },\n    close: function close() {\n      return '`';\n    }\n  }\n}; // A map of draftjs entity types -> markdown open and close characters\n// entities are different from block types because they have additional data attached to them.\n// an entity object is passed in to both open and close, in case it's needed for string generation.\n//\n// Both the open and close methods must exist, even if they simply return an empty string.\n// They should always return a string.\n\nvar EntityItems = {\n  'LINK': {\n    open: function open(entity) {\n      return '[';\n    },\n    close: function close(entity) {\n      return \"](\".concat(entity.data.url || entity.data.href, \")\");\n    }\n  }\n}; // Bit of a hack - we normally want a double newline after a block,\n// but for list items we just want one (unless it's the _last_ list item in a group.)\n\nvar SingleNewlineAfterBlock = ['unordered-list-item', 'ordered-list-item'];\n\nfunction isEmptyBlock(block) {\n  return block.text.length === 0 && block.entityRanges.length === 0 && Object.keys(block.data || {}).length === 0;\n}\n/**\n * Generate markdown for a single block javascript object\n * DraftJS raw object contains an array of blocks, which is the main \"structure\"\n * of the text. Each block = a new line.\n *\n * @param {Object} block - block to generate markdown for\n * @param {Number} index - index of the block in the blocks array\n * @param {Object} rawDraftObject - entire raw draft object (needed for accessing the entityMap)\n * @param {Object} options - additional options passed in by the user calling this method.\n *\n * @return {String} markdown string\n**/\n\n\nfunction renderBlock(block, index, rawDraftObject, options) {\n  var openInlineStyles = [],\n      markdownToAdd = [];\n  var markdownString = '',\n      customStyleItems = options.styleItems || {},\n      customEntityItems = options.entityItems || {},\n      escapeMarkdownCharacters = options.hasOwnProperty('escapeMarkdownCharacters') ? options.escapeMarkdownCharacters : true;\n  var type = block.type;\n  var markdownStyleCharactersToEscape = []; // draft-js emits empty blocks that have type set… don’t style them unless the user wants to preserve new lines\n  // (if newlines are preserved each empty line should be \"styled\" eg in case of blockquote we want to see a blockquote.)\n  // but if newlines aren’t preserved then we'd end up having double or triple or etc markdown characters, which is a bug.\n\n  if (isEmptyBlock(block) && !options.preserveNewlines) {\n    type = 'unstyled';\n  } // Render main block wrapping element\n\n\n  if (customStyleItems[type] || StyleItems[type]) {\n    if (type === 'unordered-list-item' || type === 'ordered-list-item') {\n      markdownString += ' '.repeat(block.depth * 4);\n    }\n\n    if (type === 'ordered-list-item') {\n      orderedListNumber[block.depth] = orderedListNumber[block.depth] || 1;\n      markdownString += (customStyleItems[type] || StyleItems[type]).open(block, orderedListNumber[block.depth]);\n      orderedListNumber[block.depth]++; // Have to reset the number for orderedListNumber if we are breaking out of a list so that if\n      // there's another nested list at the same level further down, it starts at 1 again.\n      // COMPLICATED 😭\n\n      if (previousOrderedListDepth > block.depth) {\n        orderedListNumber[previousOrderedListDepth] = 1;\n      }\n\n      previousOrderedListDepth = block.depth;\n    } else {\n      orderedListNumber = {};\n      markdownString += (customStyleItems[type] || StyleItems[type]).open(block);\n    }\n  } // Render text within content, along with any inline styles/entities\n\n\n  Array.from(block.text).some(function (character, characterIndex) {\n    // Close any entity tags that need closing\n    block.entityRanges.forEach(function (range, rangeIndex) {\n      if (range.offset + range.length === characterIndex) {\n        var entity = rawDraftObject.entityMap[range.key];\n\n        if (customEntityItems[entity.type] || EntityItems[entity.type]) {\n          markdownString += (customEntityItems[entity.type] || EntityItems[entity.type]).close(entity);\n        }\n      }\n    }); // Close any inline tags that need closing\n\n    openInlineStyles.forEach(function (style, styleIndex) {\n      if (style.offset + style.length === characterIndex) {\n        if (customStyleItems[style.style] || StyleItems[style.style]) {\n          var styleIndex = openInlineStyles.indexOf(style); // Handle nested case - close any open inline styles before closing the parent\n\n          if (styleIndex > -1 && styleIndex !== openInlineStyles.length - 1) {\n            for (var i = openInlineStyles.length - 1; i !== styleIndex; i--) {\n              var styleItem = customStyleItems[openInlineStyles[i].style] || StyleItems[openInlineStyles[i].style];\n\n              if (styleItem) {\n                var trailingWhitespace = TRAILING_WHITESPACE.exec(markdownString);\n                markdownString = markdownString.slice(0, markdownString.length - trailingWhitespace[0].length);\n                markdownString += styleItem.close();\n                markdownString += trailingWhitespace[0];\n              }\n            }\n          } // Close the actual inline style being closed\n          // Have to trim whitespace first and then re-add after because markdown can't handle leading/trailing whitespace\n\n\n          var trailingWhitespace = TRAILING_WHITESPACE.exec(markdownString);\n          markdownString = markdownString.slice(0, markdownString.length - trailingWhitespace[0].length);\n          markdownString += (customStyleItems[style.style] || StyleItems[style.style]).close();\n          markdownString += trailingWhitespace[0]; // Handle nested case - reopen any inline styles after closing the parent\n\n          if (styleIndex > -1 && styleIndex !== openInlineStyles.length - 1) {\n            for (var i = openInlineStyles.length - 1; i !== styleIndex; i--) {\n              var styleItem = customStyleItems[openInlineStyles[i].style] || StyleItems[openInlineStyles[i].style];\n\n              if (styleItem && openInlineStyles[i].offset + openInlineStyles[i].length > characterIndex) {\n                markdownString += styleItem.open();\n              } else {\n                openInlineStyles.splice(i, 1);\n              }\n            }\n          }\n\n          openInlineStyles.splice(styleIndex, 1);\n        }\n      }\n    }); // Open any inline tags that need opening\n\n    block.inlineStyleRanges.forEach(function (style, styleIndex) {\n      if (style.offset === characterIndex) {\n        if (customStyleItems[style.style] || StyleItems[style.style]) {\n          var styleToAdd = (customStyleItems[style.style] || StyleItems[style.style]).open();\n          markdownToAdd.push({\n            type: 'style',\n            style: style,\n            value: styleToAdd\n          });\n        }\n      }\n    }); // Open any entity tags that need opening\n\n    block.entityRanges.forEach(function (range, rangeIndex) {\n      if (range.offset === characterIndex) {\n        var entity = rawDraftObject.entityMap[range.key];\n\n        if (customEntityItems[entity.type] || EntityItems[entity.type]) {\n          var entityToAdd = (customEntityItems[entity.type] || EntityItems[entity.type]).open(entity);\n          markdownToAdd.push({\n            type: 'entity',\n            value: entityToAdd\n          });\n        }\n      }\n    }); // These are all the opening entity and style types being added to the markdown string for this loop\n    // we store in an array and add here because if the character is WS character, we want to hang onto it and not apply it until the next non-whitespace\n    // character before adding the markdown, since markdown doesn’t play nice with leading whitespace (eg '** bold**' is no  good, whereas ' **bold**' is good.)\n\n    if (character !== ' ' && markdownToAdd.length) {\n      markdownString += markdownToAdd.map(function (item) {\n        return item.value;\n      }).join('');\n      markdownToAdd.forEach(function (item) {\n        if (item.type === 'style') {\n          // We hang on to this because we may need to close it early and then re-open if there are nested styles being opened and closed.\n          openInlineStyles.push(item.style);\n        }\n      });\n      markdownToAdd = [];\n    }\n\n    if (block.type !== 'code-block' && escapeMarkdownCharacters) {\n      var insideInlineCodeStyle = openInlineStyles.find(function (style) {\n        return style.style === 'CODE';\n      });\n\n      if (insideInlineCodeStyle) {// Todo - The syntax to escape backtics when inside backtic code already is to use MORE backtics wrapping.\n        // So we need to see how many backtics in a row we have and then when converting to markdown, use that # + 1\n        // EG  ``Test ` Hllo ``\n        // OR   ```Test `` Hello```\n        // OR ````Test ``` Hello ````\n        // Similar work has to be done for codeblocks.\n      } else {\n        // Special escape logic for blockquotes and heading characters\n        if (characterIndex === 0 && character === '#' && block.text[1] && block.text[1] === ' ') {\n          character = character.replace('#', '\\\\#');\n        } else if (characterIndex === 0 && character === '>') {\n          character = character.replace('>', '\\\\>');\n        } // Escaping inline markdown characters\n        // 🧹 If someone can think of a more elegant solution, I would love that.\n        // orginally this was just a little char replace using a simple regular expression, but there’s lots of cases where\n        // a markdown character does not actually get converted to markdown, like this case: http://google.com/i_am_a_link\n        // so this code now tries to be smart and keeps track of potential “opening” characters as well as potential “closing”\n        // characters, and only escapes if both opening and closing exist, and they have the correct whitepace-before-open, whitespace-or-end-of-string-after-close pattern\n\n\n        if (MARKDOWN_STYLE_CHARACTERS.includes(character)) {\n          var openingStyle = markdownStyleCharactersToEscape.find(function (item) {\n            return item.character === character;\n          });\n\n          if (!openingStyle && block.text[characterIndex - 1] === ' ' && block.text[characterIndex + 1] !== ' ') {\n            markdownStyleCharactersToEscape.push({\n              character: character,\n              index: characterIndex,\n              markdownStringIndexStart: markdownString.length + character.length - 1,\n              markdownStringIndexEnd: markdownString.length + character.length\n            });\n          } else if (openingStyle && block.text[characterIndex - 1] === character && characterIndex === openingStyle.index + 1) {\n            openingStyle.markdownStringIndexEnd += 1;\n          } else if (openingStyle) {\n            var openingStyleLength = openingStyle.markdownStringIndexEnd - openingStyle.markdownStringIndexStart;\n            var escapeCharacter = false;\n            var popOpeningStyle = false;\n\n            if (openingStyleLength === 1 && (block.text[characterIndex + 1] === ' ' || !block.text[characterIndex + 1])) {\n              popOpeningStyle = true;\n              escapeCharacter = true;\n            }\n\n            if (openingStyleLength === 2 && block.text[characterIndex + 1] === character) {\n              escapeCharacter = true;\n            }\n\n            if (openingStyleLength === 2 && block.text[characterIndex - 1] === character && (block.text[characterIndex + 1] === ' ' || !block.text[characterIndex + 1])) {\n              popOpeningStyle = true;\n              escapeCharacter = true;\n            }\n\n            if (popOpeningStyle) {\n              markdownStyleCharactersToEscape.splice(markdownStyleCharactersToEscape.indexOf(openingStyle), 1);\n              var replacementString = markdownString.slice(openingStyle.markdownStringIndexStart, openingStyle.markdownStringIndexEnd);\n              replacementString = replacementString.replace(MARKDOWN_STYLE_CHARACTER_REGXP, '\\\\$1');\n              markdownString = markdownString.slice(0, openingStyle.markdownStringIndexStart) + replacementString + markdownString.slice(openingStyle.markdownStringIndexEnd);\n            }\n\n            if (escapeCharacter) {\n              character = \"\\\\\".concat(character);\n            }\n          }\n        }\n      }\n    }\n\n    if (character === '\\n' && type === 'blockquote') {\n      markdownString += '\\n> ';\n    } else {\n      markdownString += character;\n    }\n  }); // Close any remaining entity tags\n\n  block.entityRanges.forEach(function (range, rangeIndex) {\n    if (range.offset + range.length === block.text.length) {\n      var entity = rawDraftObject.entityMap[range.key];\n\n      if (customEntityItems[entity.type] || EntityItems[entity.type]) {\n        markdownString += (customEntityItems[entity.type] || EntityItems[entity.type]).close(entity);\n      }\n    }\n  }); // Close any remaining inline tags (if an inline tag ends at the very last char, we won't catch it inside the loop)\n\n  openInlineStyles.reverse().forEach(function (style) {\n    var trailingWhitespace = TRAILING_WHITESPACE.exec(markdownString);\n    markdownString = markdownString.slice(0, markdownString.length - trailingWhitespace[0].length);\n    markdownString += (customStyleItems[style.style] || StyleItems[style.style]).close();\n    markdownString += trailingWhitespace[0];\n  }); // Close block level item\n\n  if (customStyleItems[type] || StyleItems[type]) {\n    markdownString += (customStyleItems[type] || StyleItems[type]).close(block);\n  } // Determine how many newlines to add - generally we want 2, but for list items we just want one when they are succeeded by another list item.\n\n\n  if (SingleNewlineAfterBlock.indexOf(type) !== -1 && rawDraftObject.blocks[index + 1] && SingleNewlineAfterBlock.indexOf(rawDraftObject.blocks[index + 1].type) !== -1) {\n    markdownString += '\\n';\n  } else if (rawDraftObject.blocks[index + 1]) {\n    if (rawDraftObject.blocks[index].text) {\n      if ((type === 'unstyled' || type === 'blockquote') && options.preserveNewlines || SingleNewlineAfterBlock.indexOf(type) !== -1 && SingleNewlineAfterBlock.indexOf(rawDraftObject.blocks[index + 1].type) === -1) {\n        markdownString += '\\n\\n';\n      } else if (!options.preserveNewlines || rawDraftObject.blocks[index + 1] && !rawDraftObject.blocks[index + 1].text && rawDraftObject.blocks[index + 1].type === 'unstyled' && options.preserveNewlines) {\n        // 2 newlines if not preserving OR if this block is styled but the next block is a blank newline\n        markdownString += '\\n\\n';\n      } else {\n        markdownString += '\\n';\n      }\n    } else if (options.preserveNewlines) {\n      markdownString += '\\n';\n    }\n  }\n\n  return markdownString;\n}\n/**\n * Generate markdown for a raw draftjs object\n * DraftJS raw object contains an array of blocks, which is the main \"structure\"\n * of the text. Each block = a new line.\n *\n * @param {Object} rawDraftObject - draftjs object to generate markdown for\n * @param {Object} options - optional additional data, see readme for what options can be passed in.\n *\n * @return {String} markdown string\n**/\n\n\nfunction draftToMarkdown(rawDraftObject, options) {\n  options = options || {};\n  var markdownString = '';\n  rawDraftObject.blocks.forEach(function (block, index) {\n    markdownString += renderBlock(block, index, rawDraftObject, options);\n  });\n  orderedListNumber = {}; // See variable definitions at the top of the page to see why we have to do this sad hack.\n\n  return markdownString;\n}\n\nexport default draftToMarkdown;","map":null,"metadata":{},"sourceType":"module"}