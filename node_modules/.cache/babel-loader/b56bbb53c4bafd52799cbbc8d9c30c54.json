{"ast":null,"code":"/* eslint-disable no-param-reassign */\nvar TOKENS = {\n  WARNING: \"warning\",\n  WARNING_OPEN: \"warning_open\",\n  WARNING_CLOSE: \"warning_close\"\n};\n/**\n * Remarkable block parser that recognizes callouts.\n * @todo Add options.\n */\n\nexport var parser = function parser(state, startLine, endLine, silent) {\n  // position of line start in src + number of spaces used to indent it\n  var lineStart = state.bMarks[startLine] + state.tShift[startLine]; // position of line end in src\n\n  var lineEnd = state.eMarks[startLine]; // check if line starts with '<'\n\n  var tagMarker = state.src.charCodeAt(lineStart); // Wrong marker\n\n  if (tagMarker !== 60\n  /* '<' */\n  ) return false; // check if enough chars for <tag>\n\n  var tag = \"<warning>\";\n  var tagNumberOfChars = tag.length;\n  if (lineStart + tagNumberOfChars > lineEnd) return false;\n  var lineText = state.src.slice(lineStart, lineEnd).trim();\n  if (lineText !== tag) return false;\n  if (silent) return true; // scan for tag ending\n\n  var nextLine = startLine;\n  var hasEnding = false;\n  var insideText = \"\";\n  var tagClosed = \"</warning>\";\n\n  while (nextLine < endLine) {\n    nextLine++;\n    if (nextLine >= endLine) break;\n    var nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n    var nextLineEnd = state.eMarks[nextLine];\n    var nextLineText = state.src.slice(nextLineStart, nextLineEnd).trim();\n\n    if (state.src.charCodeAt(nextLineStart) !== tagMarker) {\n      insideText = insideText !== '' ? insideText + \"\\n\" + nextLineText : nextLineText;\n      continue;\n    }\n\n    if (nextLineText === tagClosed) {\n      hasEnding = true;\n      break;\n    }\n  } // Ensure nested parsing stops at delimiting block\n\n\n  var oldMax = state.lineMax;\n  state.lineMax = nextLine + (hasEnding ? -1 : 0);\n  var oldParentType = state.parentType;\n  state.parentType = \"button\";\n  var lines = [startLine, 0]; // Let register token and progress\n\n  state.tokens.push({\n    type: TOKENS.WARNING_OPEN,\n    level: state.level,\n    lines: lines,\n    content: insideText\n  }); // state.parser.tokenize(state, startLine + 1, nextLine);\n  // state.tokens.push({\n  //   type: TOKENS.WARNING_CLOSE,\n  //   level: state.level\n  // });\n  // Revert\n\n  lines[1] = nextLine;\n  state.line = nextLine + (hasEnding ? 1 : 0);\n  state.lineMax = oldMax;\n  state.parentType = oldParentType;\n  console.log(state);\n  return true;\n};\n/**\n * Remarkable open renderer.\n */\n\nexport function openRenderer(opts) {\n  return function (tokens, idx, options, env) {\n    return '<div style=\"background-color: red; padding: 1rem; border-radius: 1rem; color: white;\">';\n  };\n}\n/**\n * Callout closing tag renderer\n */\n\nexport function closeRenderer(opts) {\n  return function (tokens, idx, options, env) {\n    return \"</div>\";\n  };\n}\n\nvar plugin = function plugin(md, opts) {\n  md.inline.ruler.push(\"warning\", TOKENS.WARNING, parser, opts);\n  md.renderer.rules[TOKENS.WARNING_OPEN] = openRenderer(opts);\n  md.renderer.rules[TOKENS.WARNING_CLOSE] = closeRenderer(opts);\n};\n\nexport default plugin;","map":{"version":3,"sources":["/Users/antoniojps/Documents/draftjs-markdown-editor/src/RichTextEditor/remarkablePlugin.js"],"names":["TOKENS","WARNING","WARNING_OPEN","WARNING_CLOSE","parser","state","startLine","endLine","silent","lineStart","bMarks","tShift","lineEnd","eMarks","tagMarker","src","charCodeAt","tag","tagNumberOfChars","length","lineText","slice","trim","nextLine","hasEnding","insideText","tagClosed","nextLineStart","nextLineEnd","nextLineText","oldMax","lineMax","oldParentType","parentType","lines","tokens","push","type","level","content","line","console","log","openRenderer","opts","idx","options","env","closeRenderer","plugin","md","inline","ruler","renderer","rules"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\n\nconst TOKENS = {\n  WARNING: \"warning\",\n  WARNING_OPEN: \"warning_open\",\n  WARNING_CLOSE: \"warning_close\"\n};\n\n/**\n * Remarkable block parser that recognizes callouts.\n * @todo Add options.\n */\nexport const parser = (state, startLine, endLine, silent) => {\n  // position of line start in src + number of spaces used to indent it\n  const lineStart = state.bMarks[startLine] + state.tShift[startLine];\n  // position of line end in src\n  const lineEnd = state.eMarks[startLine];\n\n  // check if line starts with '<'\n  const tagMarker = state.src.charCodeAt(lineStart);\n\n  // Wrong marker\n  if (tagMarker !== 60 /* '<' */) return false;\n\n  // check if enough chars for <tag>\n  const tag = \"<warning>\";\n  const tagNumberOfChars = tag.length;\n  if (lineStart + tagNumberOfChars > lineEnd) return false;\n\n  const lineText = state.src.slice(lineStart, lineEnd).trim();\n  if (lineText !== tag) return false;\n\n  if (silent) return true;\n\n  // scan for tag ending\n  let nextLine = startLine;\n  let hasEnding = false;\n  let insideText = \"\"\n  const tagClosed = \"</warning>\";\n\n  while (nextLine < endLine) {\n    nextLine++;\n\n    if (nextLine >= endLine) break;\n\n    const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n    const nextLineEnd = state.eMarks[nextLine];\n    const nextLineText = state.src.slice(nextLineStart, nextLineEnd).trim()\n\n    if (state.src.charCodeAt(nextLineStart) !== tagMarker) {\n      insideText = insideText !== '' ? insideText + \"\\n\" + nextLineText : nextLineText\n      continue;\n    }\n    if (nextLineText === tagClosed) {\n      hasEnding = true;\n      break;\n    }\n  }\n\n  // Ensure nested parsing stops at delimiting block\n  const oldMax = state.lineMax;\n  state.lineMax = nextLine + (hasEnding ? -1 : 0);\n  const oldParentType = state.parentType;\n  state.parentType = \"button\";\n\n  const lines = [startLine, 0];\n\n  // Let register token and progress\n  state.tokens.push({\n    type: TOKENS.WARNING_OPEN,\n    level: state.level,\n    lines,\n    content: insideText,\n  });\n  // state.parser.tokenize(state, startLine + 1, nextLine);\n  // state.tokens.push({\n  //   type: TOKENS.WARNING_CLOSE,\n  //   level: state.level\n  // });\n\n  // Revert\n  lines[1] = nextLine;\n  state.line = nextLine + (hasEnding ? 1 : 0);\n  state.lineMax = oldMax;\n  state.parentType = oldParentType;\n\n  console.log(state)\n\n  return true;\n};\n\n/**\n * Remarkable open renderer.\n */\nexport function openRenderer(opts) {\n  return (tokens, idx, options, env) =>\n    '<div style=\"background-color: red; padding: 1rem; border-radius: 1rem; color: white;\">';\n}\n\n/**\n * Callout closing tag renderer\n */\nexport function closeRenderer(opts) {\n  return (tokens, idx, options, env) => \"</div>\";\n}\n\nconst plugin = (md, opts) => {\n  md.inline.ruler.push(\"warning\", TOKENS.WARNING, parser, opts);\n  md.renderer.rules[TOKENS.WARNING_OPEN] = openRenderer(opts);\n  md.renderer.rules[TOKENS.WARNING_CLOSE] = closeRenderer(opts);\n};\n\nexport default plugin;\n"]},"metadata":{},"sourceType":"module"}